Index: academy/mindswap/Client/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package academy.mindswap.Client;\r\nimport academy.mindswap.utils.Messages;\r\n\r\nimport java.io.*;\r\nimport java.net.Socket;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Scanner;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class Player {\r\n\r\n    private Socket socket;\r\n    private final String hostName = \"localhost\";\r\n    private final int portNumber = 8081;\r\n    private String clientUsername;\r\n    private double credits;\r\n    private BufferedReader bufferedReader;\r\n    private volatile boolean isRoundOver;\r\n    private volatile boolean hasRoundStarted;\r\n    private HashMap<String,Double> existingAccounts;\r\n\r\n    public Player() {\r\n        try {\r\n            this.socket = new Socket(hostName, portNumber);\r\n            askForUserNameAndCredits();\r\n\r\n        } catch (IOException e) {\r\n            System.out.println(\"Couldn't connect.\");\r\n            closeAll();\r\n        }\r\n    }\r\n\r\n    public void connectToServer ()  throws IOException {\r\n\r\n        Scanner in = new Scanner(socket.getInputStream());\r\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\r\n        new Thread(new ConnectionHandler(this.socket, out)).start();\r\n\r\n        while (in.hasNextLine()) {\r\n            String serverMessage = in.nextLine();\r\n\r\n            if(serverMessage.contains(\"\\b\")) {\r\n                System.out.print(serverMessage);\r\n                continue;\r\n            }\r\n            System.out.println(serverMessage);\r\n\r\n            if(serverMessage.startsWith(\"You lost\")) {\r\n\r\n                serverMessage = serverMessage.replace(Messages.LOSER,\"\")\r\n                        .replace(\" credits.\",\"\");\r\n\r\n                credits -= Double.parseDouble(serverMessage);\r\n                System.out.printf(Messages.CURRENT_CREDITS, credits);\r\n                isRoundOver = true;\r\n                hasRoundStarted = false;\r\n                continue;\r\n\r\n            }\r\n\r\n            if(serverMessage.startsWith(\"Congrats\")) {\r\n\r\n                serverMessage = serverMessage.replace(Messages.WINNER,\"\")\r\n                        .replace(\" credits.\",\"\");\r\n\r\n                credits += Double.parseDouble(serverMessage);\r\n                System.out.printf(Messages.CURRENT_CREDITS, credits);\r\n                isRoundOver = true;\r\n                hasRoundStarted = false;\r\n                continue;\r\n            }\r\n\r\n            if(serverMessage.startsWith(\"Starting round\")) {\r\n                hasRoundStarted = true;\r\n            }\r\n\r\n        }\r\n        socket.close();\r\n    }\r\n\r\n    public boolean checkIfStringIsValidDouble(String doubleString) {\r\n        Pattern regex = Pattern.compile(\"[^0-9]\");\r\n        return regex.matcher(doubleString).find();\r\n    }\r\n\r\n    private void readDatabase() {\r\n        try {\r\n            List<String> listOfUsers = Files.readAllLines(Paths.get(\"resources/users.txt\"));\r\n            existingAccounts = new HashMap<>();\r\n            listOfUsers.forEach(s -> existingAccounts.put(s.split(\"::\")[0], Double.parseDouble(s.split(\"::\")[1])));\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private void updateDatabase(){\r\n\r\n            StringBuilder userString = new StringBuilder();\r\n            existingAccounts\r\n                    .forEach((k,v) -> userString.append(k).append(\"::\").append(v).append(\"\\n\"));\r\n        try {\r\n            FileWriter writer = new FileWriter(\"resources/users.txt\");\r\n            writer.write(userString.toString());\r\n            writer.close();\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n\r\n    class ConnectionHandler implements Runnable {\r\n\r\n        private BufferedReader bufferedReader;\r\n        private BufferedWriter bufferedWriter;\r\n        private Socket socket;\r\n\r\n\r\n        private ConnectionHandler(Socket socket, BufferedWriter out) {\r\n            this.socket = socket;\r\n            this.bufferedWriter = out;\r\n        }\r\n\r\n        @Override\r\n        public void run () {\r\n            synchronized (this) {\r\n                while (socket.isConnected()) {\r\n                    try {\r\n                        if(socket.isClosed()) {\r\n                            break;\r\n                        }\r\n                        this.bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\r\n                        this.bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n\r\n                        bufferedWriter.write(clientUsername);\r\n                        bufferedWriter.newLine();\r\n                        bufferedWriter.flush();\r\n\r\n                        bufferedWriter.write(String.valueOf(credits));\r\n                        bufferedWriter.newLine();\r\n                        bufferedWriter.flush();\r\n\r\n\r\n                        while(!socket.isClosed()) {\r\n\r\n                            int counter = 0;\r\n                            while (!hasRoundStarted) {\r\n                                if(counter == 0) {\r\n                                    System.out.println(Messages.WAITING_FOR_ROUND);\r\n                                    counter++;\r\n                                }\r\n                            }\r\n\r\n\r\n                            this.bufferedReader = new BufferedReader(new InputStreamReader(System.in));\r\n                            String call = bufferedReader.readLine();\r\n\r\n                            if(!checkForValidCommand(call)) {\r\n                                System.out.println(Messages.VALID_COMMAND);\r\n                                continue;\r\n                            }\r\n\r\n                            bufferedWriter.write(call);\r\n                            bufferedWriter.newLine();\r\n                            bufferedWriter.flush();\r\n\r\n                            counter = 0;\r\n                            while(!isRoundOver) {\r\n\r\n                                if(call.contains(\"/bet\") && counter == 0) {\r\n                                    String bet = bufferedReader.readLine();\r\n                                    bufferedWriter.write(bet);\r\n                                    bufferedWriter.newLine();\r\n                                    bufferedWriter.flush();\r\n                                    counter++;\r\n\r\n                                }\r\n\r\n                            }\r\n\r\n\r\n\r\n                            System.out.println(Messages.CONTINUE_PLAYING);\r\n                            String decision = bufferedReader.readLine();\r\n\r\n                            if(decision.equalsIgnoreCase(\"exit\")) {\r\n                                bufferedWriter.write(decision);\r\n                                bufferedWriter.newLine();\r\n                                bufferedWriter.flush();\r\n                                closeAll();\r\n                                System.out.println(Messages.PLAYER_DISCONNECTED + clientUsername);\r\n                                break;\r\n                            }\r\n\r\n                            bufferedWriter.write(decision);\r\n                            bufferedWriter.newLine();\r\n                            bufferedWriter.flush();\r\n\r\n                            isRoundOver = false;\r\n\r\n                        }\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n                try {\r\n                    socket.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void askForUserNameAndCredits() throws IOException {\r\n\r\n        readDatabase();\r\n        this.bufferedReader = new BufferedReader(new InputStreamReader(System.in));\r\n        System.out.println(Messages.ENTER_USERNAME);\r\n        String enteredUsername = bufferedReader.readLine();\r\n\r\n        if (existingAccounts.containsKey(enteredUsername)) {\r\n            this.clientUsername = enteredUsername;\r\n            this.credits = existingAccounts.get(enteredUsername);\r\n            System.out.printf(Messages.USERNAME_ALREADY_EXISTS, this.clientUsername, this.credits);\r\n        } else {\r\n            this.clientUsername = enteredUsername;\r\n            this.credits = 10000;\r\n            existingAccounts.put(this.clientUsername,this.credits);\r\n            updateDatabase();\r\n            }\r\n        }\r\n\r\n\r\n    public void closeAll() {\r\n\r\n        try {\r\n            if (bufferedReader != null) {\r\n                bufferedReader.close();\r\n            }\r\n            if (socket != null) {\r\n                socket.close();\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private boolean checkForValidCommand(String command) {\r\n\r\n        return command.equalsIgnoreCase(\"/call\") ||\r\n                command.equalsIgnoreCase(\"/bet\") ||\r\n                command.equalsIgnoreCase(\"/fold\") ||\r\n                command.equalsIgnoreCase(\"/allin\");\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/academy/mindswap/Client/Player.java b/academy/mindswap/Client/Player.java
--- a/academy/mindswap/Client/Player.java	(revision 3e39184387a900fc2dde987fa6f8f909003fd14b)
+++ b/academy/mindswap/Client/Player.java	(date 1645728009397)
@@ -14,8 +14,8 @@
 public class Player {
 
     private Socket socket;
-    private final String hostName = "localhost";
-    private final int portNumber = 8081;
+    private final String hostName = "8.tcp.ngrok.io";
+    private final int portNumber = 11674;
     private String clientUsername;
     private double credits;
     private BufferedReader bufferedReader;
@@ -87,7 +87,7 @@
         return regex.matcher(doubleString).find();
     }
 
-    private void readDatabase() {
+    void readDatabase() {
         try {
             List<String> listOfUsers = Files.readAllLines(Paths.get("resources/users.txt"));
             existingAccounts = new HashMap<>();
